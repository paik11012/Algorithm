## 알고리즘 7.29

1. 바이트

2. 제어구조

   1. 순차구조
   2. 선택구조
   3. 반복구조

3. 자료구조

   1. 선택형 자료구조(선형) - 배열, 리스트, 문자열, 스택, 큐

   2. 비선택형 자료구조 - 트리(1차 2차 배열, 싸이클이 없는 무방향 그래프 = 트리), 그래프(인접리스트, 인접행렬) - 간선으로 표현되어 이해하기가 쉽다

      표현: 자기가 표현하기 쉬운 방식으로 바꾸는 것

      순회: 주어진 자료구조를 빠짐 없이 중복 없이 조회하는 법

   3. DFS, BFS

      DFS - 조금 더 광범위하게 사용 가능, ordering(inorder, proorder, postorder)

      BFS - 

### 조합론(순열과 조합, 부분집합)

peakless문제 = 인간이 견디는 문제, 시간복잡도가 낮음

### 완전검색  이해한 후 패턴

### 패턴(설계기법)

그리드: 탐욕알고리즘 설계기법

분할정복

백트래킹

DP - 재귀적, 반복적

 

# 1일

### 좋은 알고리즘

정확성, 작업량, 메모리 사용량, 단순성(시간 복잡도 O(n):무한갯수  vs  O(1):고정된 갯수), 최적성

### 시간복잡도

 빅 오 표개법 O(3n) O(n제곱) 최고차항만 선택해서 작성한다

O(4) = O (1)

통상적으로 O(n) 이다

### 배열 - 선형 자료구조 중

- 6개의 변수를 사용해야 하는 경우, 배열로 바꾸어 사용하기 num = [0, 1, 2, 3, 4, 5]
- 여러개의 변수가 필요한 경우, 일일이 다른 변수명을 나열해 자료에 접근하는 것은 비효율적
- 배열을 통해 하나의 선언으로 둘 이상의 변수 선언
- 타입, 대표이름, 갯수(C)
- 1차원 배열의 접근 Arr[0] 즉 인덱스 이용

ex) 상자낙하 문제

(7,4,2,0,0,6,0,7,0) 이동 범위 0~99

빨간색 상자여도 낙차가 다르다. 

아이디어: 오른쪽 끝에서부터 한 줄씩 아래로 갈 때마다 움직이는 범위가 줄어든다

뒤집기 전에는 맨 왼쪽 위에! 위>아래 & 왼쪽>오른쪽

오른쪽 장애물에 자기보다 같거나 큰 것이 있으면 그 낙차는 제외한다. 

알고리즘 작성: 슈더코드 등 이용 - 손으로 검증(몇 개 데이터 넣어서) - 코딩 - 디버깅 - 끝

ex) baby-gin game (32p)

6장 뽑기, 연속 3개 run, 같은 번호 triplet, 6장 카드가 run 또는 triplet으로 구성된 경우 baby-gin

rr rt tt 모두 baby-gin

아이디어: 우선 뽑고 정렬하기, t먼저 찾아보기, 없으면 r찾아보기

case가 여러개인 문제-case빠뜨리지 않고 조사(완전검색exaustive search-순열, 조합, 부분집합)

brute-force(여러 번 검색) 혹은 generate-and-test(모든케이스 생성해 조사-back tracking)라고도 불린다

6개 숫자 순열 구하기 - 앞에것 3개, 뒤에것 3개가 r과 t이냐 - babygin결론 내기 (예외케이스x) 

720개 데이터 = 7!/3!



## 순열(순서 존재)

nPr 서로 다른 몇 개를 뽑아서 한줄로 나열하는 것 = n * n-1 *  * (n-r+1)

* 탐욕Greedy 알고리즘 ⊂  설계기법

최적해: 여러개 중 하나 결정

최적해-실행가능성 검사-전역해인가

ex) 거스름돈 동전 갯수 구하기

1700 = 1000 500 100 100

앞에서 1000해결, 나머지 700해결해라

해선택 : 5000원짜리를 선택한다! 가능? 불가능

​			  그러면 1000원짜리를 선택한다. 가능. 그러면 700원 남은것이 전역해냐? no

700원에서 1000원선택, 불가. 500원 가능. 전역해? 아니다

200원에서 100원 선택. 전역해? 아니다

100원에서 100원 선택. 전역해? 맞다

ex) 줄 돈 80 거스름돈 시스템 50 40 10

Greedy 80 - 50 = 30, 10 10 10 이렇게 접근

그러나 40 40 으로 접근하면 더 편한데? 그래서 Greedy적 접근이 좋지 않다.

완전검색으로 접근할 것. 깊이가 가장 낮은것으로 선택(트리구조 높이 체크)

그렇다면 greedy로 구할 수는 없을까?

* counts라는 배열 만들기! 6개 숫자의 빈도 체크하기

r 발견시 삭제하고 다음 것 조사 - 나머지 3개 조사

t 발견시 삭제하고 다음 것 조사 - 나머지 3개 조사

continue만나면 i +=1 패스하고 위로 올라가게 된다, 제자리 인덱스에서 검색

continue가 있으면 그 밑에 명령어 처리하지 않는다(제어문)

만약 두 if문의 순서가 바뀌었다면? 3 1 2 2 1 3 불가능

그래서 정렬 이용!



# 정렬

버블, 삽입, 선택 O(n^2)

퀵, 병합, 합 정렬 O(nlogn) 2^6

카운팅정렬 O(n)

## 버블정렬 O(n^2)

엎어져 있는 3 장 카드 중 가장 큰 값 찾기, 할 수 있는 것은 비교와 저장 뿐

비교해서 뒤로 보내기, 맨 뒤에 잇는 것이 가장 크다

데이터가 n개이면 접근은 n-1개

![](C:\Users\student\Desktop\캡처w.JPG)

두개씩 비교하며 가장큰 것 맨 뒤에로 보내기

```python
def bubblesort(a):
	for i in range(len(a)-1, 0, -1):
		for j in range(0, i):
			if a[j] > a[j+1]:
				a[j], a[j+1] = a[j+1], a[j]
```

숫자 i가 4 3 2 1 0으로 줄어든다

## 카운팅정렬

조건 2개: 범위가 존재, 요소가 정수형(type)

0~4

0 4 1 3 1 2 4 1

0 1 2 3 4 한개씩 세기(counts에 저장)

정렬

A: 0 1 1 1 2 3 4 4

C: 0 4 5 6 8 ( 0 1 2 3 4 정렬하기 위해 잠깐 들림, k) 

B: 12345678

순서를 유지하며 정렬하기에 4째줄

n + k + n = 2n + k 결론 n에 디펜드된다

beeback@다음 백경원

서울2반1월1일백민주 , 4개 내기, 그날 12시까지(내일) - zip제목똑같이

*어제 조망권 문제 리뷰

