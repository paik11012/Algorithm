## 목차

1. Recursion
2. Insertion sort
3. Quick sort
4. Counting sort
5. Binary search
6. DFS searching
7. BFS Searching
8. Parametric Search
9. Dynamic Programming
10. Permutation and combination
11. DFS Algorithm
12. BFS Algorithm
13. Dijkstra
14. Floyd Warshall
15. Plane Sweeping
16. Minimum spanning tree
17. Topological sort
18. Maximum flow
19. Bipartite match
20. 간단 개념들



## 1. Recursion 재귀

 재귀는 수학이나 컴퓨터 과학 등에서 자신을 정의할 때 자기 자신을 재참조하는 방법을 뜻한다. 주로 이 방법은 함수에 적용한 재귀 함수(Recursion Function)의 형태로 많이 사용된다. 

주어진 수의 Factorial 값을 구해 아래와 같이 출력하시오. 주어지는 수는 1 이상 20 이하의 수이다.

input

```
3 // 전체 Test case 수  
9 // Test case index  
12 
20
```

output

```
#1 9! = 362880 
#2 12! = 479001600 
#3 20! = 2432902008176640000
```

python

```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)


def main():
    T = int(input())

    for test_case in range(1, T + 1):
        num = int(input())
        value = factorial(num)
        print("#%d %d! = %d" % (test_case, num, value))


if __name__ == "__main__":
    main()
```

C코드

```c
#include <stdio.h>

long long factorial(int num)
{
	if (num == 0)
	{
		return 1;
	}
	else
	{
		return num * factorial(num - 1);
	}
}


int main(void)
{
	int test_case;
	int T;
	int num;
	long long value;

	scanf("%d", &T);

	for (test_case = 1; test_case <= T; ++test_case)
	{
		scanf("%d", &num);
		value = factorial(num);
		printf("#%d %d! = %lld\n", test_case, num, value);
	}
}
```



## 2. Insertion Sort 삽입정렬

 삽입 정렬은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.  

주어진 데이터를 Insertion Sort를 사용하여 정렬 하시오. 데이터의 최대 크기는 100이다.

input

```
1 // 전체 Test case 수 
5 // 데이터 크기 
1 4 5 2 3
```

output

```
#1 1 2 3 4 5
```

python

```python
arr = []
num = 0


def insertionSort():
    global arr
    for i in range(1, num):
        temp = arr[i]
        j = i - 1

        while temp < arr[j] and j >= 0:
            arr[j + 1] = arr[j]
            j = j - 1

        arr[j + 1] = temp


def printResult():
    for i in range(0, num):
        print(arr[i], end=' ')


def main():
    global arr, num
    T = int(input())

    for test_case in range(1, T + 1):
        num = int(input())
        arr = [int(x) for x in input().split()]

        insertionSort()
        print("#%d" % test_case, end=' ')
        printResult()


if __name__ == "__main__":
    main()
```

C코드

```c
#include <stdio.h>

#define MAX_NUM 100

int input[MAX_NUM];
int num;

void insertionSort(void)
{
	int temp;
	int i;
	int j;

	for (i = 1; i < num; i++)
	{
		temp = input[i];
		j = i - 1;

		while ((temp < input[j]) && (j >= 0))
		{
			input[j + 1] = input[j];
			j = j - 1;
		}
		input[j + 1] = temp;
	}
}

void printResult(void)
{
	int i;

	for (i = 0; i < num; ++i)
	{
		printf("%d ", input[i]);
	}
	printf("\n");
}

int main(void)
{
	int T;
	int test_case;
	int i;

	scanf("%d", &T);

	for (test_case = 1; test_case <= T; test_case++)
	{
		scanf("%d", &num);
		for (i = 0; i < num; i++)
		{
			scanf("%d", &input[i]);
		}
		insertionSort();
		printf("#%d ", test_case);
		printResult();
	}

	return 0;
}
```



## 3. Quick Sort 퀵 정렬

퀵 정렬은 기준키(pivot)를 기준으로 작거나 같은 값을 지닌 데이터는 앞으로, 큰 값을 지닌 데이터는 뒤로 가도록 하여 작은 값을 갖는 데이터와 큰 값을 갖는 데이터로 분리해가며 정렬하는 방법이다. 

주어진 데이터를 Quick Sort를 사용하여 정렬 하시오. 데이터의 최대 크기는 100이다.

input

```
1 // 전체 Test case 수 
5 // 데이터 크기 
1 4 5 2 3
```

output

```
#1 1 2 3 4 5
```

python

```python
arr = []
num = 0


def quick_sort(first, last):
    if first < last:
        pivot = first
        i = first
        j = last

        while i < j:
            while arr[i] <= arr[pivot] and i < last:
                i += 1
            while arr[j] > arr[pivot]:
                j -= 1
            if i < j:
                arr[i], arr[j] = arr[j], arr[i]

        arr[pivot], arr[j] = arr[j], arr[pivot]

        quick_sort(first, j - 1)
        quick_sort(j + 1, last)


def main():
    global arr, num
    T = int(input())

    for test_case in range(1, T + 1):
        num = int(input())
        arr = [int(x) for x in input().split()]

        quick_sort(0, num - 1)
        print("#%d" % test_case, end=' ')
        for j in range(0, num):
            print(arr[j], end=' ')
        print()


if __name__ == "__main__":
    main()
```

C코드

```c
#include <stdio.h>

#define MAX_NUM 100

int input[MAX_NUM];
int num;

void quickSort(int first, int last)
{
	int pivot;
	int i;
	int j;
	int temp;
	
	if (first < last)
	{
		pivot = first;
		i = first;
		j = last;

		while (i < j)
		{
			while (input[i] <= input[pivot] && i < last)
			{
				i++;
			}
			while (input[j] > input[pivot])
			{
				j--;
			}
			if (i < j)
			{
				temp = input[i];
				input[i] = input[j];
				input[j] = temp;
			}
		}

		temp = input[pivot];
		input[pivot] = input[j];
		input[j] = temp;

		quickSort(first, j - 1);
		quickSort(j + 1, last);
	}
}

void printResult(void)
{
	int i;

	for (i = 0; i < num; ++i)
	{
		printf("%d ", input[i]);
	}
	printf("\n");
}

int main(void)
{
	int T;
	int test_case;
	int i;

	scanf("%d", &T);

	for (test_case = 1; test_case <= T; test_case++)
	{
		scanf("%d", &num);
		for (i = 0; i < num; i++)
		{
			scanf("%d", &input[i]);
		}
		quickSort(0, num - 1);
		printf("#%d ", test_case);
		printResult();
	}

	return 0;
}
```



## 4. Counting Sort  계수정렬

 계수정렬(counting sort)는 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하면서 정렬하는 알고리즘이다.  

주어진 정수들을 Counting Sort를 이용하여 정렬하고 오름차순으로 출력하라. (주어진 정수들은 중복가능)

input

```
2 // # of test case 
10 // # of data set 
0 2 9 4 5 1 0 7 3 9 
5 
4 9 5 1 3
```

output

```
#1 0 0 1 2 3 4 5 7 9 9 
#2 1 3 4 5 9
```

python

```python
MAX_N = 100
MAX_DIGIT = 10

N = 0
arr = []
cnt = []
sortedArr = []


def calculateDigitNumber():
    global cnt
    for i in range(N):
        cnt[arr[i]] += 1

    for i in range(1, MAX_DIGIT + 1):
        cnt[i] = cnt[i - 1] + cnt[i]


def executeCountingSort():
    global cnt, sortedArr
    for i in range(N - 1, -1, -1):
        sortedArr[cnt[arr[i]] - 1] = arr[i]
        cnt[arr[i]] = cnt[arr[i]] - 1


def main():
    global N, arr, cnt, sortedArr
    T = int(input())

    for test_case in range(1, T + 1):
        N = int(input())
        arr = [int(x) for x in input().split()]
        sortedArr = [int(0)] * N
        cnt = [int(0)] * 11

        calculateDigitNumber()
        executeCountingSort()

        print("#%d" % test_case, end=' ')
        for i in range(N):
            print("%d" % sortedArr[i], end=' ')

        print()


if __name__ == "__main__":
    main()
```

c코드

```c
#include <stdio.h>

#define MAX_N 100
#define MAX_DIGIT 10

int N;  // # of data set
int arr[MAX_N];
int cnt[MAX_DIGIT];
int sortedArr[MAX_N];

void calculateDigitNumber()
{
    for (int i = 0; i < N; i++)
    {
        cnt[arr[i]]++;
    }

    for (int i = 1; i < MAX_DIGIT; i++)
    {
        cnt[i] = cnt[i-1] + cnt[i];
    }
}

void executeCountingSort()
{
    for (int i = N-1; i >= 0; i--)
    {
        sortedArr[--cnt[arr[i]]] = arr[i];
    }
}

int main(void)
{
    int T;
    scanf("%d", &T);

    for (int test_case = 1; test_case <= T; test_case++) 
    {
        scanf("%d", &N);

        for (int i = 0; i < N; i++)
        {
            scanf("%d", &arr[i]);
        }

        // initialize
        for (int i = 1; i < MAX_DIGIT; i++)
        {
            cnt[i] = 0;
        }

        calculateDigitNumber();
        executeCountingSort();

        //print the sorted digits
        printf("#%d ", test_case);
        for (int i = 0; i < N; i++) 
        {
            printf("%d ", sortedArr[i]);
        }
        printf("\n");
    }
    return 0;
}
```



## 5. Binary Search 이진검색 알고리즘 (이진탐색)

 이진 검색 알고리즘(binary search algorithm)은 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이며, 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있다. 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최고값이 되며, 작으면 그 값은 새로운 최하값이 된다.  

정렬된 정수배열에서 Binary Search를 이용하여 제시된 숫자들을 찾아라. 있으면 해당 인덱스를 출력하고, 없으면 -1 를 출력하라. (2 ≤ M ≤ 100)

input

```
2 // # of test case T 
12 // # of element in array M 
5 // # of numbers to search N 
3 7 28 29 43 49 55 58 69 77 79 99 // sorted integer array 
8 49 58 44 7 // numbers to search 
7 
3 
3 4 5 6 7 8 9 
1 2 3
```

output

```
#1 -1 5 7 -1 1 
#2 -1 -1 0
```

python

```python
def binarySearch(arr, low, high, target):
    if low > high:
        print("-1", end=' ')
        return

    mid = (low + high) // 2

    if target < arr[mid]:
        binarySearch(arr, low, mid - 1, target)
    elif arr[mid] < target:
        binarySearch(arr, mid + 1, high, target)
    else:
        print(mid, end=' ')
        return


def main():
    T = int(input())

    for test_case in range(1, T + 1):
        print("#%d" % test_case, end=' ')
        M = int(input())
        N = int(input())

        arr = list(map(int, input().split()))
        targetvalue = list(map(int, input().split()))

        for idx in range(N):
            binarySearch(arr, 0, M - 1, targetvalue[idx])
        print()


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define MAX_M 100

int T;    // # of test case
int M;    // # of element in array
int N;    // # of numbers to search
int arr[MAX_M];

void binarySearch(int* arr, int low, int high, int target)
{
    int mid;
    if (low > high) 
    {
        printf("-1 ");
        return;
    }

    mid = (low + high) / 2;

    if (target < arr[mid])
    {
        binarySearch(arr, low, mid - 1, target);
    }
    else if (arr[mid] < target)
    {
        binarySearch(arr, mid + 1, high, target);
    }
    else 
    {
        printf("%d ", mid);
        return;
    }
}

int main(void)
{
    int targetValue;
    scanf("%d", &T);

    for (int test_case = 1; test_case <= T; test_case++) 
    {
        printf("#%d ", test_case);
        scanf("%d %d", &M, &N);

        for (int i = 0; i < M; i++)
        {
            scanf("%d", &arr[i]);
        }

        for (int i = 0; i < N; i++) 
        {
            scanf("%d", &targetValue);
            binarySearch(arr, 0, M-1, targetValue);
        }
        printf("\n");
    }
    return 0;
}
```



## 6. DFS Searching 깊이 우선 탐색

깊이 우선 탐색은 맹목적 탐색방법의 하나로 한 노드를 시작으로 인접한 다른 노드를 재귀적으로 탐색해가고 끝까지 탐색하면 다시 위로 와서 다음을 탐색하여 검색한다.

img

위와 같은 그래프에서 숫자가 있는 원은 정점(Vertex)라고 하고, 정점과 정점을 잇는 연결선을 간선(Edge)이라고 한다. 정점의 최대 개수는 30개이다. 정점과 정점의 연결관계가 인접행렬로 주어졌을 때, DFS를 이용하여 시작 정점으로부터 모든 정점을 탐색한 결과를 순서대로 화면에 출력하시오.

input

```
1 //test case 개수 
8 1 // 정점의 개수, 시작 정점 
1 2 // 정점 간 연결 관계. 1과 2가 연결 
1 3 
2 4 
2 5 
4 8 
5 8 
3 6 
3 7 
6 8 
7 8 
-1 -1 // 입력 끝
```

output

```
#1 1 2 4 8 5 6 3 7 // 방문한 정점 순서
```

python

```python
def depthFirstSearch(v, depth):
    global maxEdge

    if v == end:
        if maxEdge < 0 or depth < maxEdge:
            maxEdge = depth
        return

    visit[v] = True

    for i in range(1, vertex + 1):
        if MAP[v][i] == 1 and visit[i] is False:
            depthFirstSearch(i, depth + 1)
            visit[i] = False


def main():
    global vertex, end, visit, MAP, maxEdge

    T = int(input())

    for test_case in range(1, T + 1):
        vertex, edge, start, end = map(int, input().split())
        MAP = [[0] * (vertex + 1) for _ in range(vertex + 1)]
        visit = [False] * (vertex + 1)
        for _ in range(edge):
            v1, v2 = map(int, input().split())
            MAP[v1][v2] = 1
        maxEdge = -1
        depthFirstSearch(start, 0)
        print("#%d %d" % (test_case, maxEdge))


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define MAX_VERTEX 30

int vertex;
int map[MAX_VERTEX][MAX_VERTEX];
int visit[MAX_VERTEX];

void depthFirstSearch(int v)
{
	int i;
	visit[v] = 1;
	for (i = 1; i <= vertex; i++)
	{
		if (map[v][i] == 1 && !visit[i]) 
		{
			printf("%d ", i);
			depthFirstSearch(i);
		}
	}
}

int main(void)
{
	int T;
	int test_case;
	int i,j;
	int start;
	int v1;
	int v2;

	scanf("%d", &T);

	for (test_case = 1; test_case <= T; test_case++)
	{
		for (i = 0; i < MAX_VERTEX; i++)
		{
			for (j = 0; j < MAX_VERTEX; j++)
			{
				map[i][j] = 0;
			}
			visit[i] = 0;
		}

		scanf("%d %d", &vertex, &start);

		while (true)
		{
			scanf("%d %d", &v1, &v2);
			if (v1 == -1 && v2 == -1)
			{
				break;
			}
			map[v1][v2] = map[v2][v1] = 1;
		}

		printf("#%d ", test_case);
		printf("%d ", start);
		depthFirstSearch(start);
		printf("\n");
	}

	return 0;
}
```



## 7. BFS Searching 너비 우선 탐색

너비 우선 탐색은 맹목적 탐색방법의 하나로 시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이다.

img

위와 같은 그래프에서 숫자가 있는 원은 정점(Vertex)라고 하고, 정점과 정점을 잇는 연결선을 간선(Edge)이라고 한다. 정점의 최대 개수는 30개이다. 정점과 정점의 연결관계가 인접행렬로 주어졌을 때, BFS를 이용하여 시작 정점으로부터 모든 정점을 탐색한 결과를 순서대로 화면에 출력하시오.

input

```
1 //test case 개수 
8 1 // 정점의 개수, 시작 정점 
1 2 // 정점 간 연결 관계. 1과 2가 연결 
1 3 
2 4 
2 5 
4 8 
5 8 
3 6 
3 7 
6 8 
7 8 
-1 -1 // 입력 끝
```

output

```
#1 1 2 3 4 5 6 7 8 // 방문한 정점 순서
```

python

```python
class Queue:
    class Point:
        def __init__(self, y, x, c):
            self.y = y
            self.x = x
            self.c = c

    def __init__(self, capacity):
        self.queue = [0] * capacity
        self.head = self.rear = 0

    def isEmpty(self):
        return self.head <= self.rear

    def enQueue(self, y, x, c):
        self.queue[self.head] = self.Point(y, x, c)
        self.head = self.head + 1

    def deQueue(self):
        if self.isEmpty():
            return None
        self.rear = self.rear + 1
        return self.queue[self.rear - 1]


def breadthFirstSearch():
    queue = Queue(row * column)
    queue.enQueue(0, 0, 0)
    MAP[0][0] = 0

    while queue.isEmpty() == False:
        p = queue.deQueue()

        if p.y == row - 1 and p.x == column - 1:
            return p.c

        if p.y + 1 < row and MAP[p.y + 1][p.x]:
            queue.enQueue(p.y + 1, p.x, p.c + 1)
            MAP[p.y + 1][p.x] = 0
        if p.x + 1 < column and MAP[p.y][p.x + 1]:
            queue.enQueue(p.y, p.x + 1, p.c + 1)
            MAP[p.y][p.x + 1] = 0
        if p.y - 1 >= 0 and MAP[p.y - 1][p.x] != 0:
            queue.enQueue(p.y - 1, p.x, p.c + 1)
            MAP[p.y - 1][p.x] = 0
        if p.x - 1 > 0 and MAP[p.y][p.x - 1] != 0:
            queue.enQueue(p.y, p.x - 1, p.c + 1)
            MAP[p.y][p.x - 1] = 0

    return -1


def main():
    global MAP, row, column
    T = int(input())

    for test_case in range(1, T + 1):
        row, column = map(int, input().split())
        MAP = [[int(num) for num in input().split()] for _ in range(row)]
        print("#%d %d" % (test_case, breadthFirstSearch()))


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define MAX_VERTEX 30

int num;
int map[MAX_VERTEX][MAX_VERTEX];
int visit[MAX_VERTEX];
int queue[MAX_VERTEX];
int rear, front;

void breadthFirstSearch(int vertex)
{
	int i;
	
	visit[vertex] = 1; 
	printf("%d ", vertex);
	queue[rear++] = vertex;
	while (front < rear)
	{
		vertex = queue[front++];
		for (i = 1; i <= num; i++)
		{
			if (map[vertex][i] == 1 && !visit[i])
			{
				visit[i] = 1;
				printf("%d ", i);
				queue[rear++] = i;
			}
		}
	}
}

int main(void)
{
	int T;
	int test_case;
	int i,j;
	int start;
	int v1;
	int v2;

	scanf("%d", &T);

	for (test_case = 1; test_case <= T; test_case++)
	{

		for (i = 0; i < MAX_VERTEX; i++)
		{
			for (j = 0; j < MAX_VERTEX; j++)
			{
				map[i][j] = 0;
			}
			visit[i] = 0;
			queue[i] = 0;
		}
		front = 0;
		rear = 0;

		scanf("%d %d", &num, &start);

		while (true)
		{
			scanf("%d %d", &v1, &v2);
			if (v1 == -1 && v2 == -1)
			{
				break;
			}
			map[v1][v2] = map[v2][v1] = 1;
		}

		printf("#%d ", test_case);
		breadthFirstSearch(start);
		printf("\n");
	}

	return 0;
}
```



## 8. Parametric Search

 parametric search는 어떤 알고리즘으로 해를 바로 구해내는 것이 아니고, 임의의 값을 던지고 맞는지 확인해가며 해를 구하는 방법이다.  

길이가 각각 다른 K개의 리본을 가지고 있다. 공예작품을 만들기 위해 가지고 있는 리본을 잘라서 길이가 동일한 N개의 리본재료를 만들려고 한다. 리본재료의 최대 길이를 구하시오 ( 1 <= K <= 10,000;  1 <= N <= 1,000,000; K <= N ) 

- 손실되는 길이는 없음 
- 만들 수 없는 경우는 없다 
- 이미 자른 리본은 붙일 수 없다 
- 자를 때는 정수 cm 단위로 자른다.

input

```
1 // test case 개수 
4 // 가지고 있는 리본의 개수 K 
11 // 필요한 리본재료의 개수 N 
802 
743 
457 
539
```

output

```
#1 200
```

python

```python
MAX_RIBBON = 100

K = 0
N = 0
sizeRibbonTape = [None for _ in range(MAX_RIBBON)]


def search(low, high):
    max = -1

    while low <= high:
        mid = low + (high - low) // 2

        numRibbonTape = 0
        for i in range(K):
            numRibbonTape += sizeRibbonTape[i] // mid

        if numRibbonTape >= N:
            low = mid + 1
            if max < mid:
                max = mid
        else:
            high = mid - 1

    return max


def main():
    global K, N

    T = int(input())

    for test_case in range(1, T + 1):
        low, high = 1, 0
        K = int(input())
        N = int(input())

        for i in range(K):
            sizeRibbonTape[i] = int(input())
            if high < sizeRibbonTape[i]:
                high = sizeRibbonTape[i]

        max = search(low, high)

        print("#%d %d" % (test_case, max))


if __name__ == "__main__":
    main()
```

c

```CQL
#include <stdio.h>

#define MAX_RIBBON 100

int K;
int N;
int low, high, mid, numRibbonTape, max;
int sizeRibbonTape[MAX_RIBBON];

void search()
{
    mid = low + (high - low) / 2;
    numRibbonTape = 0;

    for (int i = 0; i < K ; i++) 
    {
        numRibbonTape += (sizeRibbonTape[i] / mid);
    }

    if (numRibbonTape >= N)
    {
        low = mid + 1;
        if (max < mid)
            max = mid;
    }
    else
    {
        high = mid - 1;
    }
}

int main(int argc, char** argv)
{
    int T;
    scanf("%d", &T);

    for (int test_case = 1; test_case <= T; test_case++) 
    {
        low = 1;
        high = 0 ;
        max = -1;

        scanf("%d %d", &K, &N);

        for (int i = 0; i < K; i++)
        {
            scanf("%d", &sizeRibbonTape[i]);
            if ( high < sizeRibbonTape[i] )
            {
                high = sizeRibbonTape[i] ;
            }
        }

        while (low <= high)
        {
            search();
        }
        printf("#%d ", test_case);
        printf("%d\n", max);
    }
    return 0;
}
```



## 9. Dynamic Programming 동적 계획법

동적 계획법(Dynamic programming)은 복잡한 문제를 풀기위해서 간단한 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 목적에 도달하는 방법이다

[문제]  상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이  2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다. 상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을  공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위,  아래에 있는 스티커는 사용할 수 없게 된다.

img

모든 스티커를 붙일 수 없게 된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가  되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다.  상냥이가 뗄 수 있는 스티커의 점수의 최대값을 구하는 프로그램을 작성하시오.  즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커  집합을 구해야 한다. 위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이  최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에,  동시에 뗄 수 없다.

[입력]  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.

[출력]  각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최대값을 출력한다.

input

```
2 
5 
50 10 100 20 40 
30 50 70 10 60 
7 
10 30 10 50 100 20 40 
20 40 30 50 60 20 80
```

output

```
#1 260 
#2 290
```

python

```python
N = 0
dp = None
board = None


def findSticker():
    global dp
    dp[0][0] = board[0][0]
    dp[1][0] = board[1][0]
    dp[0][1] = dp[1][0] + board[0][1]
    dp[1][1] = dp[0][0] + board[1][1]

    for i in range(2, N):
        dp[0][i] = max(dp[0][i - 2], dp[1][i - 2])
        dp[0][i] = max(dp[1][i - 1], dp[0][i])
        dp[0][i] += board[0][i]

        dp[1][i] = max(dp[0][i - 2], dp[1][i - 2])
        dp[1][i] = max(dp[0][i - 1], dp[1][i])
        dp[1][i] += board[1][i]


def main():
    global N, board, dp

    T = int(input())

    for test_case in range(1, T + 1):
        N = int(input())

        board = [[int(num) for num in input().split()] for _ in range(2)]
        dp = [[0] * 100001 for _ in range(2)]

        findSticker()

        print("#%d %d" % (test_case, max(dp[0][N - 1], dp[1][N - 1])))


if __name__ == "__main__":
    main()
```

c

```c
#include<stdio.h>

int N;
int dp[2][100001];
int board[2][100001];

const int max(const int a, const int b) 
{
    return (a<b) ? b : a;
}

void findSticker() 
{
    dp[0][0] = board[0][0];
    dp[1][0] = board[1][0];
    dp[0][1] = dp[1][0] + board[0][1];
    dp[1][1] = dp[0][0] + board[1][1];

    for (int i = 2; i < N; i++) 
    {
        dp[0][i] = max(dp[0][i - 2], dp[1][i - 2]);
        dp[0][i] = max(dp[1][i - 1], dp[0][i]);
        dp[0][i] += board[0][i];

        dp[1][i] = max(dp[0][i - 2], dp[1][i - 2]);
        dp[1][i] = max(dp[0][i - 1], dp[1][i]);
        dp[1][i] += board[1][i];
    }
}

int main() 
{
    int T;
    scanf("%d", &T);

    for (int test_case = 1; test_case <= T; test_case++) 
    {
        printf("#%d ", test_case);
        scanf("%d", &N);
        for (int j = 0; j < 2; j++) 
        {
            for (int i = 0; i < N; i++) 
            {
                scanf("%d", &board[j][i]);
            }
        }
        findSticker();
        printf("%d\n", max(dp[0][N - 1], dp[1][N - 1]));
    }

    return 0;
}
```



## 10. Permutation & Combination 순열과 조합

 순열조합(permutation combination), 순열은 순서가 부여된 임의의 집합을 다른 순서로 뒤섞는 연산이며, 조합은 집합에서 일부 원소를 취해 부분 집합을 만드는 방법을 말한다. 주어진 문자열 str (길이 n)에 대해 아래 두 가지를 차례로 출력하시오. 1. str의 n개 character를 일렬로 배열하는 모든 경우를 출력하시오. 2. str의 n개 character 중 k개를 취하는 모든 경우를 출력하시오. (제한사항: 주어진 string에 동일한 알파벳이 중복으로 포함되지 않음. String의 maximum size는 10. k <= n.)

input

```
1 // # of test case 
ABCD 
3 // n 
2 // k
```

output

```
`#1 ABC ACB BAC BCA CBA CAB AB AC BC`
```

python

```python
combinationStack = []


def printString(cArr):
    for i in cArr:
        print(i, end='')
    print()


def swap(cArr, x, y):
    cArr[x], cArr[y] = cArr[y], cArr[x]


def permutation(cArr, l, r):
    if l == r:
        printString(cArr)
    else:
        for i in range(l, r + 1, 1):
            swap(cArr, l, i)
            permutation(cArr, l + 1, r)
            swap(cArr, l, i)


def push(ch):
    combinationStack.append(ch)


def pop():
    combinationStack.pop()


def combination(cArr, length, offset, k):
    if k == 0:
        printString(combinationStack)
    else:
        for i in range(offset, length - k + 1, 1):
            push(cArr[i])
            combination(cArr, length, i + 1, k - 1)
            pop()


def main():
    global cArr, N, K
    T = int(input())

    for test_case in range(1, T + 1):
        cArr = list(input())

        N = int(input())
        K = int(input())

        print("#%d" % test_case)

        permutation(cArr[0:N], 0, N - 1)
        combination(cArr, N, 0, K)


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define MAX_STRING_LENGTH 10

int stackTop = 0;
char combinationStack[MAX_STRING_LENGTH];

void swap(char *x, char *y)
{
    char temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

void permutation(char *str, int l, int r)
{
    if (l == r)
    {
        printf("%s\n", str);
    }
    else 
    {
        for (int i = l; i <= r; i++) 
        {
            swap((str+l), (str+i));
            permutation(str, l+1, r);
            swap((str+l), (str+i)); //backtrack
        }
    }
}

void push(char ch) 
{
    combinationStack[stackTop++] = ch;
    combinationStack[stackTop] = '\0';
}

void pop() 
{
    combinationStack[--stackTop] = '\0';
}

void combination(const char* str, int length, int offset, int k) 
{
    if (k == 0) 
    {
        printf("%s\n", combinationStack);
        return;
    }
    for (int i = offset; i <= length - k; ++i) 
    {
        push(str[i]);
        combination(str, length, i+1, k-1);
        pop();
    }
}

int main()
{
    int N, K, T;
    char str[MAX_STRING_LENGTH];
    scanf("%d", &T);

    for (int test_case = 1; test_case <= T; test_case++) 
    {
        scanf("%s%d%d", str, &N, &K);
        str[N] = 0;
        printf("#%d\n", test_case);

        permutation(str, 0, N-1);
        combination(str, N, 0, K);
    }

    return 0;
}
```



## 11. DFS Algorithm 깊이 우선 탐색

깊이 우선 탐색은 맹목적 탐색방법의 하나로 한 노드를 시작으로 인접한 다른 노드를 재귀적으로 탐색해가고 끝까지 탐색하면 다시 위로 와서 다음을 탐색하여 검색한다.

img

위와 같은 그래프에서 숫자가 있는 원은 정점(Vertex)라고 하고, 정점과 정점을 잇는 연결선을 간선(Edge)이라고 한다. 정점의 최대 개수는 30개이다. 간선의 길이를 1이라고 하고, N개의 정점과 M개의 간선이 주어졌을 때, DFS를 이용하여 시작점으로부터 도착점까지의 최단 경로를 찾아 거리를 출력하시오. 시작점에서 도착점으로 갈 수 있는 방법이 없는 경우 -1을 출력하시오.

input

```
2 // test case 개수 
8 10 1 8// 정점의 수, 간선의 수, 시작점, 도착점 
1 2 // 정점 간 연결 관계. 1에서 2로 이동 가능 
1 3 
2 7 
2 4 
3 5 
3 6 
4 7 
5 7 
6 7 
6 8 
8 10 2 8 
1 2 
1 3 
2 7 
2 4 
3 5 
3 6 
4 7 
5 7 
6 7 
6 8
```

output

```
#1 3 // 최단경로의 길이 
#2 -1
```

python

```PYTHON
def depthFirstSearch(v, depth):
    global maxEdge

    if v == end:
        if maxEdge < 0 or depth < maxEdge:
            maxEdge = depth
        return

    visit[v] = True

    for i in range(1, vertex + 1):
        if MAP[v][i] == 1 and visit[i] is False:
            depthFirstSearch(i, depth + 1)
            visit[i] = False


def main():
    global vertex, end, visit, MAP, maxEdge

    T = int(input())

    for test_case in range(1, T + 1):
        vertex, edge, start, end = map(int, input().split())
        MAP = [[0] * (vertex + 1) for _ in range(vertex + 1)]
        visit = [False] * (vertex + 1)
        for _ in range(edge):
            v1, v2 = map(int, input().split())
            MAP[v1][v2] = 1
        maxEdge = -1
        depthFirstSearch(start, 0)
        print("#%d %d" % (test_case, maxEdge))


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define MAX_VERTEX 30

int map[MAX_VERTEX][MAX_VERTEX];
int visit[MAX_VERTEX];
int vertex;
int edge;
int maxEdge;
int start;
int end;

void depthFirstSearch(int v, int depth)
{
	int i;
	if (v == end) 
	{
		if (maxEdge < 0 || depth < maxEdge)
		{
			maxEdge = depth;
		}
		return;
	}

	visit[v] = 1;
	for (i = 1; i <= vertex; i++) 
	{
		if (map[v][i] == 1 && !visit[i]) 
		{
			depthFirstSearch(i, depth + 1);
			visit[i] = 0;
		}
	}
}


int main(void)
{
	int T;
	int test_case;
	int i;
	int v1;
	int v2;

	scanf("%d", &T);

	for (test_case = 1; test_case <= T; test_case++)
	{
		scanf("%d %d %d %d", &vertex, &edge, &start, &end);

		for (i = 0; i < edge; i++)
		{
			scanf("%d %d", &v1, &v2);
			map[v1][v2] = 1;
		}

		maxEdge = -1;
		depthFirstSearch(start, 0);
		printf("#%d %d\n", test_case, maxEdge);
	}
	return 0;
}
```



## 12. BFS Algorithm 너비 우선 탐색

 너비 우선 탐색은 맹목적 탐색방법의 하나로 시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이다.  0과 1로 이뤄진 지도에서 상하좌우 만으로 이동이 가능할 때, 좌상단(1, 1)에서 우하단(R, C)까지 최단 거리를 구하시오. 이때, 범위 외의 지역은 벽으로 가정하고, 1로 표시된 곳으로만 이동이 가능하다. 지도의 크기는 R, C로 주어지며, 그 범위는 1 <= R, C <= 50로 한정한다.

input

```
2 // test case 개수 
4 5 // R, C 
1 1 1 1 0 // MAP, 
1 0 1 0 0 // 0: 벽 
1 1 0 0 1 // 1: 길 
0 1 1 1 1 // 테두리는 벽으로 가정 
10 10 
1 1 1 1 1 1 0 1 1 1 
1 0 0 0 0 1 0 1 0 1 
1 0 0 0 0 1 1 1 0 1 
1 0 0 1 1 1 0 0 0 1 
1 0 0 1 0 1 0 1 1 1 
1 0 0 1 0 1 1 1 0 1 
1 0 0 1 0 0 1 0 0 1 
1 1 0 1 1 1 0 0 0 1 
0 1 0 1 0 1 1 1 0 1 
0 1 1 1 0 0 1 1 1 1
```

output

```
#1 7 
#2 20
```

python

```python
class Queue:
    class Point:
        def __init__(self, y, x, c):
            self.y = y
            self.x = x
            self.c = c

    def __init__(self, capacity):
        self.queue = [0] * capacity
        self.head = self.rear = 0

    def isEmpty(self):
        return self.head <= self.rear

    def enQueue(self, y, x, c):
        self.queue[self.head] = self.Point(y, x, c)
        self.head = self.head + 1

    def deQueue(self):
        if self.isEmpty():
            return None
        self.rear = self.rear + 1
        return self.queue[self.rear - 1]


def breadthFirstSearch():
    queue = Queue(row * column)
    queue.enQueue(0, 0, 0)
    MAP[0][0] = 0

    while queue.isEmpty() == False:
        p = queue.deQueue()

        if p.y == row - 1 and p.x == column - 1:
            return p.c

        if p.y + 1 < row and MAP[p.y + 1][p.x]:
            queue.enQueue(p.y + 1, p.x, p.c + 1)
            MAP[p.y + 1][p.x] = 0
        if p.x + 1 < column and MAP[p.y][p.x + 1]:
            queue.enQueue(p.y, p.x + 1, p.c + 1)
            MAP[p.y][p.x + 1] = 0
        if p.y - 1 >= 0 and MAP[p.y - 1][p.x] != 0:
            queue.enQueue(p.y - 1, p.x, p.c + 1)
            MAP[p.y - 1][p.x] = 0
        if p.x - 1 > 0 and MAP[p.y][p.x - 1] != 0:
            queue.enQueue(p.y, p.x - 1, p.c + 1)
            MAP[p.y][p.x - 1] = 0

    return -1


def main():
    global MAP, row, column
    T = int(input())

    for test_case in range(1, T + 1):
        row, column = map(int, input().split())
        MAP = [[int(num) for num in input().split()] for _ in range(row)]
        print("#%d %d" % (test_case, breadthFirstSearch()))


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define MAX_N 50

int MAP[MAX_N + 2][MAX_N + 2];
int queue[MAX_N * MAX_N][3];
int row;
int column;
int head;
int rear;

int isEmpty()
{
	return (head <= rear) ? 1 : 0;
}

int enqueue(int x, int y, int c)
{
	queue[head][0] = x;
	queue[head][1] = y;
	queue[head][2] = c;
	head++;
	return 1;
}

int dequeue(int *x, int *y, int *c)
{
	if (isEmpty())
	{
		return 0;
	}
	*x = queue[rear][0];
	*y = queue[rear][1];
	*c = queue[rear][2];
	rear++;
	return 1;
}

int breadthFirstSearch()
{
	int x;
	int y;
	int c;

	enqueue(1, 1, 0);
	MAP[1][1] = 0;
	while (!isEmpty()) 
	{
		dequeue(&x, &y, &c);
		if (x == column && y == row)
		{
			return c;
		}
		if (x + 1 <= column && MAP[x + 1][y]) 
		{
			enqueue(x + 1, y, c + 1);
			MAP[x + 1][y] = 0;
		}
		if (y + 1 <= row && MAP[x][y + 1]) 
		{
			enqueue(x, y + 1, c + 1);
			MAP[x][y + 1] = 0;
		}
		if (x - 1 > 0 && MAP[x - 1][y]) 
		{
			enqueue(x - 1, y, c + 1);
			MAP[x - 1][y] = 0;
		}
		if (y - 1 > 0 && MAP[x][y - 1]) 
		{
			enqueue(x, y - 1, c + 1);
			MAP[x][y - 1] = 0;
		}
	}
	return -1;
}


int main(void)
{
	int test_case;
	int T;

	scanf("%d", &T);

	for (test_case = 1; test_case <= T; test_case++) 
	{
		head = 0;
		rear = 0;
		scanf("%d %d", &row, &column);

		for (int i = 1; i <= row; i++) 
		{
			for (int j = 1; j <= column; j++)
			{
				scanf("%d", &MAP[j][i]);
			}
		}
		printf("#%d %d\n", test_case, breadthFirstSearch());
	}
	return 0;
}
```



## 13. Dijkstra 데이크스트라 알고리즘

 데이크스트라 알고리즘은 어떤 변도 음수 가중치를 갖지 않는 유향 그래프에서 주어진 출발점과 도착점 사이의 최단 경로 문제를 푸는 알고리즘이다.  

방향이 있는 그래프에서 꼭지점들을 연결하는 비용이 할당 되었을 때 임의의 꼭지점에서 다른 꼭지점으로 가는 경로들 중에서 비용이 가장 적게 드는 경로, 즉 두 정점 사이의 최단 경로를 찾아라. 

입력 값 첫번째 라인에는 전체 테스트 케이스의 개수가 입력된다. 두번째 라인에는 정점의 개수, 그리고 시작 정점, 도착 정점이 입력된다. 이때, 정점의 최대 개수는 100이다. 세번째 라인에는 정점을 잇는 간선 개수(m)가 입력된다. 네번째 라인부터는 연결 된 정점 값 2개와 간선에 할당 된 비용이 m번 들어온다. 이때 간선 방향은 첫번째 입력된 정점에서 두번째 입력된 정점으로 가는 방향이다.

input

```
1 // test case 개수 
7 1 7 // 정점의 개수, 그리고 시작 정점, 도착 정점 
9 // 간선 개수 
1 2 4 // 1->2, 비용은 4 
1 3 2 
2 4 1 
2 5 2 
3 4 7 
3 6 3 
4 7 3 
5 7 1 
6 7 5
```

output

```
#1 7
```

python 

```python
N = 100
INF = 100000
MAP = [[0] * (N + 1) for _ in range(N + 1)]
visit = [False] * (N + 1)
dist = [0] * (N + 1)


def dijkstra():
    global dist, visit, MAP
    v = 0
    dist[start] = 0

    for i in range(1, vertex + 1):
        min = INF
        for j in range(1, vertex + 1):
            if visit[j] == False and min > dist[j]:
                min = dist[j]
                v = j

        visit[v] = True

        for j in range(1, vertex + 1):
            if dist[j] > dist[v] + MAP[v][j]:
                dist[j] = dist[v] + MAP[v][j]


def main():
    global MAP, dist, visit, vertex, start

    T = int(input())

    for test_case in range(1, T + 1):
        vertex, start, end = map(int, input().split())
        edge = int(input())

        for i in range(1, vertex + 1):
            for j in range(1, vertex + 1):
                if i != j:
                    MAP[i][j] = INF

        for i in range(1, edge + 1):
            FROM, TO, value = map(int, input().split())
            MAP[FROM][TO] = value

        for i in range(1, vertex + 1):
            dist[i] = INF
            visit[i] = False

        dijkstra()
        print("#%d %d" % (test_case, dist[end]))


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define N 100
#define INF 100000

int map[N + 1][N + 1];
int visit[N + 1];
int dist[N + 1];
int vertex;
int edge;
int start;
int end;

void dijkstra(void)
{
	int i;
	int j;
	int min;
	int v;

	dist[start] = 0;

	for (i = 1; i <= vertex; i++)
	{
		min = INF;

		for (j = 1; j <= vertex; j++)
		{
			if (visit[j] == 0 && min > dist[j])
			{
				min = dist[j];
				v = j;
			}
		}

		visit[v] = 1;

		for (j = 1; j <= vertex; j++)
		{
			if (dist[j] > dist[v] + map[v][j])
			{
				dist[j] = dist[v] + map[v][j];
			}
		}
	}
}

int main(void)
{
	int test_case;
	int T;
	int i;
	int j;
	int from;
	int to;
	int value;

	scanf("%d", &T);

	for (test_case = 1; test_case <= T; test_case++)
	{
		scanf("%d %d %d", &vertex, &start, &end);
		scanf("%d", &edge);

		for (i = 1; i <= vertex; i++)
		{
			for (j = 1; j <= vertex; j++)
			{
				if (i != j)
				{
					map[i][j] = INF;
				}
			}
		}

		for (i = 1; i <= edge; i++) 
		{
			scanf("%d %d %d", &from, &to, &value);
			map[from][to] = value;
		}

		for (i = 1; i <= vertex; i++)
		{
			dist[i] = INF;
			visit[i] = 0;
		}

		printf("#%d ", test_case);
		dijkstra();
		printf("%d \n", dist[end]);
	}
	return 0;
}
```



## 14. Floyd Warshall 플로이드-워셜 알고리즘

 플로이드-워셜 알고리즘(Floyd-Warshall Algorithm)은 그래프에서 모든 꼭짓점 사이의 최단 경로의 거리를 구하는 알고리즘이다. 제일 바깥쪽 반복문은 거쳐가는 꼭짓점이고, 두 번째 반복문은 출발하는 꼭짓점, 세 번째 반복문은 도착하는 꼭짓점이다. 

N 개의 정점(Vertex)과 방향과 가중치 w를 가진 M개의 간선(edge)으로 이루어진 방향 그래프(Directed Graph)가 주어진다. 예를 들어 Figure 1의 경우 N이 5, M이 10인 방향 그래프이다. 이때 모든 정점들의 쌍(A, B)에 대해 A에서 시작하여 B로 도착하는 최단 거리를 구하시오.

img

input

```
1 // # of test case 
5 // 정점 개수 N (1 <= N <= 100) 
10 // 간선 개수 M (1 <= M <= 10,000) 
1 2 2 // 1번 정점-> 2번 정점 중 가중치 2의 간선 // (1 <= w <= 100) 
1 3 3 
2 1 1 
3 1 8 
3 4 5 
4 1 6 
4 2 1 
4 5 10 
5 2 2 
5 4 8
```

output

```
#1 // N * N 최단 거리 맵 출력 
0 2 3 8 18 
1 0 4 9 19 
7 6 0 5 15 
2 1 5 0 10 
3 2 6 8 0
```

python

```python
INFINITY = 999999


def floyd():
    for k in range(n):
        for i in range(n):
            if k == 0:
                for j in range(n):
                    result[i][j] = weight[i][j]
            for j in range(n):
                if result[i][k] + result[k][j] < result[i][j]:
                    result[i][j] = result[i][k] + result[k][j]


def main():
    global result, weight, n

    T = int(input())

    for test_case in range(1, T + 1):

        n = int(input())
        m = int(input())

        result = [[0] * n for _ in range(n)]
        weight = [[INFINITY] * n for _ in range(n)]
        for i in range(n):
            weight[i][i] = 0

        for _ in range(m):
            st, en, w = map(int, input().split())
            if weight[st - 1][en - 1] > w:
                weight[st - 1][en - 1] = w

        floyd()

        print("#%d" % test_case)
        for i in range(n):
            for j in range(n):
                print(result[i][j], end=' ')
            print()


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>
#define INFINITY 999999

int weight[101][101];
int result[101][101];

void floyd(int n) 
{
    int i, j, k;

    for (k = 0; k < n; k++) 
    {
        for (i = 0; i < n; i++) 
        {
            if (k == 0) 
            {
                for (j = 0; j < n; j++) 
                {
                    result[i][j] = weight[i][j];
                }
            }
            for (j = 0; j < n; j++) 
            {
                if (result[i][k] + result[k][j] < result[i][j])
                {
                    result[i][j] = result[i][k] + result[k][j];
                }
            }
        }
    }
}

int main() 
{
    int T;
    int n, m, i, j;
    scanf("%d", &T);

    for (int test_case = 1; test_case <= T; test_case++) 
    {
        scanf("%d %d", &n, &m);
        for (i = 0; i < n; i++) 
        {
            for (j = 0; j < n; j++) 
            {
                weight[i][j] = INFINITY;
            }
            weight[i][i] = 0;
        }

        for (i = 0; i < m; i++) 
        {
            int st, en, w;
            scanf("%d %d %d", &st, &en, &w);
            if (weight[st-1][en-1] > w)
            {
                weight[st-1][en-1] = w;
            }
        }

        floyd(n);

        printf("#%d\n", test_case);
        for (i = 0; i < n; i++) 
        {
            for (j = 0; j < n; j++) 
            {
                printf("%d ", result[i][j]);
            }
            printf("\n");
        }
    }
}
```



## 15. Plane Sweeping

 Plane sweeping은 여러 개의 직사각형이 주어졌을 때, 총 넓이를 구하는 알고리즘이다.  

테스트케이스 수 T와 지도의 수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 각 지도의 정보가 주어진다. 지도의 정보는 네 정수 x1, y1, x2, y2 (0 ≤ x1 < x2 ≤ 30,000, 0 ≤ y1 < y2 ≤ 30,000)으로 이루어져 있다. (x1, y1)와 (x2, y2)은 직사각형의 왼쪽 아래 좌표와 오른쪽 위 좌표이다. 모든 지도는 직사각형이고, 변은 항상 x축 또는 y축에 평행하다. 첫째 줄에 지도를 모두 합쳤을 때, 그 면적을 출력한다. (직사각형을 모두 합쳤을 때 면적)

input

```
1 // T, # of testcases 
2 // N, # of given maps 
10 10 20 20 
15 15 25 30
```

output

```
#1 225
```

python

```python
class Rec:
    def __init__(self, x, y1, y2, end):
        self.x = x
        self.y1 = y1
        self.y2 = y2
        self.end = end


def update(x, left, right, nodeLeft, nodeRight, val):
    global tree
    if left > nodeRight or right < nodeLeft:
        return
    if left <= nodeLeft and right >= nodeRight:
        cnt[x] += val
    else:
        mid = (nodeLeft + nodeRight) >> 1
        update(x * 2, left, right, nodeLeft, mid, val)
        update(x * 2 + 1, left, right, mid + 1, nodeRight, val)

    tree[x] = 0
    if cnt[x] > 0:
        tree[x] = nodeRight - nodeLeft + 1
    if cnt[x] == 0 and nodeLeft < nodeRight:
        tree[x] = tree[x * 2] + tree[x * 2 + 1]


def main():
    global tree, cnt
    T = int(input())

    for test_case in range(1, T + 1):

        N = int(input())

        v = [0] * N * 2

        idx = 0
        for _ in range(N):
            x1, y1, x2, y2 = map(int, input().split())
            v[idx] = Rec(x1, y1, y2, 1)
            idx = idx + 1
            v[idx] = Rec(x2, y1, y2, -1)
            idx = idx + 1

        v = sorted(v, key=lambda rec: rec.x)

        tree = [0] * 65538
        cnt = [0] * 65538
        px = v[0].x
        ans = 0
        for i in range(0, idx):
            ans += (v[i].x - px) * tree[1]
            update(1, v[i].y1, v[i].y2 - 1, 0, 32768, v[i].end)

            px = v[i].x

        print("#%d %d" % (test_case, ans))


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

int N;
#define MAX_N 10000

typedef struct rec
{
    int x, y1, y2, end;
} rec;

rec make_rec(int _x,int _y1,int _y2,int _end)
{
    rec t = {_x, _y1, _y2, _end};
    return t;
}

int rec_greater_than(rec* a, rec* b)
{
    return a->x != b->x ? a->x > b->x : 0;
}

int tree[65538],cnt[65538];

void update(int x, int left, int right, int nodeLeft, int nodeRight, int val)
{
    if (left > nodeRight || right < nodeLeft)
    {
        return;
    }
    if (left <= nodeLeft && right >= nodeRight)
    {
        cnt[x] += val;
    }
    else 
    {
        int mid = (nodeLeft + nodeRight) >> 1;
        update(x * 2, left, right, nodeLeft, mid, val);
        update(x * 2 + 1, left, right, mid + 1, nodeRight, val);
    }
    tree[x] = 0;
    if (cnt[x] > 0)
    {
        tree[x] = nodeRight - nodeLeft + 1;
    }
    if (cnt[x] == 0 && nodeLeft < nodeRight)
    {
        tree[x] = tree[x * 2] + tree[x * 2 + 1];
    }
}

int partition(rec a[], int l, int r)
{
    rec pivot, t;
    int i, j;
    pivot = a[l];
    i = l;
    j = r + 1;

    while (1) {
        do{
            ++i;
        } while ((!rec_greater_than(&a[i],  &pivot)) && i <= r);

        do{
            --j;
        } while (rec_greater_than(&a[j], &pivot));

        if (i >= j)
        {
            break;
        }
        t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    t = a[l];
    a[l] = a[j];
    a[j] = t;
    return j;
}


void quick_sort(rec a[], int l, int r)
{
    int j;

    if (l < r) 
    {
        j = partition(a, l, r);
        quick_sort(a, l, j - 1);
        quick_sort(a, j + 1, r);
    }
}

int main()
{
    int T;
    scanf("%d", &T);

    for (int test_case = 1; test_case <= T; test_case++) 
    {
        static rec v[MAX_N * 2];
        scanf("%d",&N);

        int idx = 0, i, px, ans;
        for (i = 0; i < N; i++) 
        {
            int x1, y1, x2, y2;
            scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
            v[idx++] = make_rec(x1,y1,y2,1);
            v[idx++] = make_rec(x2,y1,y2,-1);
        }

        quick_sort(v, 0 , idx - 1);
        px = v[0].x;
        ans = 0;
        for (i = 0; i < idx; i++) 
        {
            ans += (v[i].x - px) * tree[1];
            update(1, v[i].y1, v[i].y2-1, 0, 32768, v[i].end);
            px = v[i].x;
        }
        printf("#%d ", test_case);
        printf("%d\n",ans);
    }

    return 0;
}
```



## 16. Minimum Scanning Tree 최소비용 신장트리

 최소비용 신장트리(minimum spanning tree)는 네트워크(가중치가 간선에 할당된 그래프)에 있는 모든 정점들을 가장 적은 비용으로 연결하는 트리를 말한다. 

주어진 weighted graph에 대해 Minimum Spanning Tree를 구하고, 연결된 모든 Edge의 weight 합을 출력하시오. 첫째 줄에는 테스트 케이스의 수 T 및 Vertex의 개수 V가 들어온다. 두 번째 줄부터는 V x V개의 숫자가 들어오며, 이는 edge[i][j]의 weight를 나타내는 숫자이다 (단, V는 100을 넘지 않는다고 가정한다)

input

```
1 5 // T - test case, V - Vertex 개수 
0 2 0 6 0 
2 0 3 8 5 
0 3 0 0 7 
6 8 0 0 9 
0 5 7 9 0
```

output

```
#1 16
```

python 

```python
def minKey(key, mstSet):
    min = 2147483647
    for v in range(0, V):
        if (mstSet[v] == 0) and (key[v] < min):
            min = key[v]
            min_index = v
    return min_index


def printMST(parent):
    weightSum = 0
    for i in range(1, V):
        weightSum += graph[i][parent[i]]
    print(weightSum)


def primMST():
    parent = [0] * 100
    key = [2147483647] * 100
    mstSet = [0] * 100
    key[0] = 0
    parent[0] = -1
    for count in range(0, V - 1):
        u = minKey(key, mstSet)
        mstSet[u] = 1
        for v in range(0, V):
            if graph[u][v] and (mstSet[v] == 0) and graph[u][v] < key[v]:
                parent[v] = u
                key[v] = graph[u][v]
    printMST(parent)


def main():
    global graph, V
    T, V = map(int, input().split())
    for test_case in range(1, T + 1):
        graph = [[int(x) for x in input().split()] for y in range(V)]
        print("#%d" % test_case, end=' ')
        primMST()


if __name__ == "__main__":
    main()
```

c

```c
#include<stdio.h>

int V;
int graph[100][100];

int minKey(int *key, unsigned char *mstSet)
{
    int min = 2147483647;
    int min_index;

    for (int v = 0; v < V; v++)
    {
        if (mstSet[v] == 0 && key[v] < min) 
        {
            min = key[v];
            min_index = v;
        }
    }

    return min_index;
}

void printMST(int parent[])
{
    int weightSum = 0;
    for (int i = 1; i < V; i++)
    {
        weightSum += graph[i][parent[i]];
    }
    printf("%d\n", weightSum);
}

void primMST()
{
     int parent[100];
     int key[100];
     unsigned char mstSet[100];

     for (int i = 0; i < V; i++) 
     {
        key[i] = 2147483647;
        mstSet[i] = 0;
     }

     key[0] = 0;
     parent[0] = -1;

     for (int count = 0; count < V-1; count++)
     {
        int u = minKey(key, mstSet);

        mstSet[u] = 1;

        for (int v = 0; v < V; v++)
        {
          if (graph[u][v] && mstSet[v] == 0 && graph[u][v] <  key[v])
          {
             parent[v]  = u, key[v] = graph[u][v];
          }
        }
     }

     printMST(parent);
}

int main(void) 
{
    int i, j, T;
    scanf("%d", &T);

    for (int test_case = 1; test_case <= T; test_case++) 
    {
        printf("#%d ", test_case);
        scanf("%d", &V);

        for (i = 0; i < V; i++) 
        {
            for (j = 0; j < V; j++) 
            {
                scanf("%d", &graph[i][j]);
            }
        }

        primMST();
    }

    return 0;
}
```



## 17. Topological Sort 위상정렬

위상 정렬(topological sorting)은 유향 그래프의 정점(vertex)을 간선의 방향을 거스르지 않도록 나열하는 것을 의미한다.

img

위와 같은 그래프에서 숫자가 있는 원은 정점(Vertex)라고 하고, 정점과 정점을 잇는 연결선을 간선(Edge)이라고 한다. N(<=25)개의 정점과 M(<=25)개의 간선이 주어졌을 때, 도착점 D 까지의 위상정렬을 구하시오.

input

```
3 // 테스트 개수 
8 7 // 정점의 수, 간선의 수 
1 // 목적지 
2 1 // 2번 정점에서 1번 정점으로의 간선 
3 1 
4 2 
6 3 
8 3 
5 4 
7 5 
5 6 
1 
3 1 
2 1 
3 2 
4 2 
4 3 
5 4 
7 7 
1 
2 1 
4 1 
6 2 
3 2 
2 4 
5 4 
7 5
```

output

```
#1 7 5 4 2 8 6 3 1 
#2 5 4 3 2 1 
#3 7 5 6 3 2 4 1
```

python

```python
MAX_N = 25
MAX_M = 25
CONNECTED = 1
NOT_CONNECTED = 0
NOT_UPDATED_YET = 0
NOT_VISITED = -1
DUPLICATE = -2

Map = [[0] * MAX_N for i in range(MAX_N)]
count = [0] * MAX_N
queue = []
stack = []
nodes = []


def mark_duplicate(item):
    for i in range(0, len(stack)):
        if stack[i] == item:
            stack[i] = DUPLICATE


class Node:
    def __init__(self, item):
        self.item = item
        self.prev = None

    def reset(self):
        self.prev = None

    def push(self, other):
        if self.prev == None:
            self.prev = other
            return
        head = self
        while head.prev != None:
            head = head.prev
        head.prev = other


for i in range(0, MAX_N):
    nodes.append(Node(i))


def reset():
    for i in range(0, MAX_N):
        for j in range(0, MAX_N):
            Map[i][j] = 0
    for i in range(0, MAX_N):
        count[i] = 0
    queue.clear()
    stack.clear()
    for i in range(0, MAX_N):
        nodes[i].reset()


def connected(src, dest):
    return Map[src][dest] == CONNECTED


def traverse(idx):
    mark_duplicate(nodes[idx].item)
    stack.append(nodes[idx].item)
    cur = nodes[idx].prev
    while cur != None:
        traverse(cur.item)
        cur = cur.prev


def main():
    T = int(input())

    for test_case in range(1, T + 1):
        n, m = map(int, input().split())
        dest = int(input())
        reset()

        for i in range(0, m):
            s, d = map(int, input().split())
            Map[s - 1][d - 1] = CONNECTED
            count[d - 1] += 1

        for i in range(0, n):
            if count[i] == 0:
                queue.append(i)

        while len(queue) > 0:
            src = queue.pop(0)
            for i in range(0, n):
                if connected(src, i):
                    node = Node(src)
                    nodes[i].push(node)
                    count[i] -= 1
                    if count[i] == 0:
                        queue.append(i)

        print("#%d " % test_case, end='')

        if nodes[dest - 1].prev == None:
            print("Not reached")
        else:
            traverse(dest - 1)
            while len(stack) > 0:
                item = stack.pop()
                if item == DUPLICATE:
                    continue
                print("%d " % (item + 1), end='')
            print()


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_N 25
#define MAX_M 25
#define CONNECTED 1
#define NOT_CONNECTED 0
#define NOT_UPDATED_YET 0
#define NOT_VISITED -1
#define DUPLICATE -2

int map[MAX_N][MAX_N] = {0, };
int count[MAX_N] = {0, };
int test_case, n, m;

typedef struct {
	int queue[MAX_N];
	int cur_ptr;
	int last_ptr;
} Queue;

void queue_reset(Queue* queue) 
{
	queue->cur_ptr = 0;
	queue->last_ptr = 0;
}

int queue_has_item(Queue* queue) 
{
	return queue->last_ptr - queue->cur_ptr > 0;
}

int queue_dequeue(Queue* queue) 
{
	return queue->queue[queue->cur_ptr++];
}

void queue_enqueue(Queue* queue, const int item) 
{
	queue->queue[queue->last_ptr++] = item;
}

typedef struct {
	int stack_set[MAX_N];
	int last_ptr;
} Stack;


void stack_reset(Stack* stack) 
{
	stack->last_ptr = 0;
}

int stack_has_item(Stack* stack) 
{
	return stack->last_ptr > 0;
}

int stack_peek(Stack* stack) 
{
	return stack->stack_set[stack->last_ptr - 1];
}

int stack_pop(Stack* stack) 
{
	return stack->stack_set[--stack->last_ptr];
}

void stack_set_mark_duplicate(Stack* stack, const int item) 
{
	int i;
	for (i = 0; i < stack->last_ptr; i++) 
	{
		if (stack->stack_set[i] == item)
		{
			stack->stack_set[i] = DUPLICATE;
		}
	}
}

void stack_set_push(Stack* stack, const int item) 
{
	stack_set_mark_duplicate(stack, item);

	stack->stack_set[stack->last_ptr++] = item;
}

typedef struct _Node {
	int item;
	struct _Node* prev;
} Node;

void node_reset(Node* node) 
{
	Node* cur = node->prev;
	while (cur) 
	{
		Node* temp = cur;
		cur = temp->prev;
		free(temp);
	}
	node->prev = NULL;
}

void node_push(Node* node, Node* other) 
{
	if (node->prev == NULL) 
	{
		node->prev = other;
		return;
	}

	Node* head = node;
	while (head->prev != NULL) 
	{
		head = head->prev;
	}

	head->prev = other;
}

int connected(const int src, const int dest) 
{
	return map[src][dest] == CONNECTED;
}

void put_starting_point(Queue* queue)
{
	int i;
	for (i = 0; i < n; i++) 
	{
		if (count[i] == 0) 
		{
			queue_enqueue(queue, i);
		}
	}
}

void init(Node* nodes) 
{
	int i;
	for (i = 0; i < MAX_N; i++) 
	{
		nodes[i].item = i;
		nodes[i].prev = NULL;
	}
}

void reset(Stack* stack, Queue* queue, Node* nodes) 
{
	int i, j;
	for (i = 0; i < MAX_N; i++) 
	{
		for (j = 0; j < MAX_N; j++) 
		{
			map[i][j] = 0;
		}
	}
	for (i = 0; i < MAX_N; i++) 
	{
		count[i] = 0;
	}

	stack_reset(stack);
	queue_reset(queue);
	for (i = 0; i < MAX_N; i++) 
	{
		node_reset(&nodes[i]);
	}
}


void traverse(Node* nodes, const int idx, Stack* stack) 
{
	stack_set_push(stack, nodes[idx].item);

	Node* cur = nodes[idx].prev;
	while (cur) 
	{
		traverse(nodes, cur->item, stack);
		cur = cur->prev;
	}
}

int main(void) 
{
	int dest, tc, i;
	Queue queue;
	Stack stack;
	Node nodes[MAX_N];
	init(nodes);

	scanf("%d", &test_case);

	for (tc = 1; tc <= test_case; tc++) 
	{
		scanf("%d %d", &n, &m);
		scanf("%d", &dest);

		reset(&stack, &queue, nodes);

		for (i = 0; i < m; i++) 
		{
			int src, dest;
			scanf("%d %d", &src, &dest);
			map[src - 1][dest - 1] = CONNECTED;
			count[dest - 1]++;
		}

		put_starting_point(&queue);

		while (queue_has_item(&queue)) 
		{
			int src = queue_dequeue(&queue);
			for (i = 0; i < n; i++)
			{
				if (connected(src, i)) 
				{
					Node* node = (Node*) malloc(sizeof(Node));
					node->item = src;
					node->prev = NULL;
					node_push(&nodes[i], node);

					count[i]--;
					if (count[i] == 0)
					{
						queue_enqueue(&queue, i);
					}
				}
			}
		}

		printf("#%d  ", tc);
		if (!nodes[dest - 1].prev) 
		{
			printf("Not reached");
		} 
		else 
		{
			traverse(nodes, dest - 1, &stack);
			while (stack_has_item(&stack)) 
			{
				int item = stack_pop(&stack);
				if (item == DUPLICATE)
				{
					continue;
				}

				printf("%d ", item + 1);
			}
		}
		printf("\n");
	}

	return 0;
}
```



## 18. Maximum Flow

 Network flow란 각각의 간선에 정해진 용량보다 작은 유량이 주어진 방향그래프를 말하며, Maximum flow란 위 수원지(S)에서 수요지(T)까지 공급할 수 있는 최대 유량을 말한다. 

V (2<= V <=10)개의 정점과 E (2<= E <=20)개의 간선이 용량을 갖는 그래프에서 두 정점 사이에 얼마나 많은 유량을 보낼 수 있는지를 계산하여 출력하시오, 각 간선의 유량은 해당 간선의 용량을 초과할 수 없다. 

첫 라인은 테스트 케이스 수, 두번째 라인은 수원지, 수요지를 포함한 정점의 수와 그를 연결하는 방향성을 띈 간선의 수가 입력되며, 다음 라인 부터는 간선의 정보가 입력된다 간선의 정보는 출발지, 도착지, 용량 순이다.

img

input

```
2 // 테스트 케이스 수 
6 10 // 정점, 간선의 수
0 1 16 
0 2 13 
1 2 10 
1 3 12 
2 1 4 
2 4 14 
3 2 9 
3 5 20 
4 3 7 
4 5 4 
6 7 
0 1 10 
0 3 8 
1 2 10 
1 4 6 
2 5 10 
3 2 8 
4 5 6
```

output

```
#1 23 
#2 16
```

python

```python
MAX_V = 10
INF = 987654321
V = 0


def networkFlow(source, sink):
    flow = [[0] * MAX_V for i in range(MAX_V)]
    parent = [0] * MAX_V
    totalFlow = 0
    while True:
        for p in range(0, V):
            parent[p] = -1
        q = list()
        parent[source] = source
        q.append(source)
        while len(q) > 0:
            here = q[0]
            q.pop(0)
            for there in range(0, V):
                if (capacity[here][there] - flow[here][there] > 0) and (parent[there] == -1):
                    q.append(there)
                    parent[there] = here
        if parent[sink] == -1:
            break
        amount = INF
        p = sink
        while p != source:
            if capacity[parent[p]][p] - flow[parent[p]][p] > amount:
                amount = amount
            else:
                amount = capacity[parent[p]][p] - flow[parent[p]][p]
            p = parent[p]
        p = sink
        while p != source:
            flow[parent[p]][p] += amount
            flow[p][parent[p]] -= amount
            p = parent[p]
        totalFlow += amount
    return totalFlow


def main():
    global V, E, capacity

    T = int(input())
    for test_case in range(1, T + 1):
        V, E = map(int, input().split())
        capacity = [[0] * MAX_V for i in range(MAX_V)]
        for i in range(0, E):
            here, there, C = map(int, input().split())
            capacity[here][there] = C
        answer = networkFlow(0, V - 1)
        print("#%d %d" % (test_case, answer))


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define MAX_V 10

const int INF = 987654321;
int V;

typedef struct
{
	int queueArray[MAX_V];
	int front;
	int rear;
}Queue;

void push(Queue *q, int item)  
{
	if ((q->rear + 1) % MAX_V == q->front)
	{
		return;
	}
	q->queueArray[q->rear] = item;
	q->rear = (q->rear + 1) % MAX_V;
}
void pop(Queue * q)
{
	if (q->front == q->rear)
	{
		return;
	}
	q->front = (q->front + 1) % MAX_V;
}

int getFront(Queue * q)
{
	return q->queueArray[q->front];
}

int isEmpty(Queue *q)
{
	if (q->rear == q->front) 
	{ 
		return 1;
	}
	else
	{
		return 0;
	}
}

int networkFlow(int source, int sink, int capacity[][MAX_V])
{
	int flow[MAX_V][MAX_V] = { 0, };
	int parent[MAX_V];
	int totalFlow = 0;
	int p;
	while (1)
	{
		for (p = 0; p < V; p++)
		{
			parent[p] = -1;
		}

		Queue q;
		
		q.front = 0;
		q.rear = 0;

		parent[source] = source;
		push(&q, source);

		while (!isEmpty(&q)) 
		{
			int here = getFront(&q); pop(&q);
			int there;
			for (there = 0; there < V; ++there) 
			{
				if (capacity[here][there] - flow[here][there] > 0 && parent[there] == -1)
				{
					push(&q, there);
					parent[there] = here;
				}
			}
		}
		if (parent[sink] == -1)
		{
			break;
		}

		int amount = INF;
		for (p = sink; p != source; p = parent[p]) 
		{
			if (capacity[parent[p]][p] - flow[parent[p]][p] > amount) 
			{
				amount = amount;
			}
			else {
				amount = capacity[parent[p]][p] - flow[parent[p]][p];
			}
		}

		for (p = sink; p != source; p = parent[p]) 
		{
			flow[parent[p]][p] += amount;
			flow[p][parent[p]] -= amount;
		}
		totalFlow += amount;
	}
	return totalFlow;
}

int main(int argc, char** argv)
{
	int T;

	setbuf(stdout, NULL);
	scanf("%d", &T);

	for (int test_case = 1; test_case <= T; ++test_case)
	{
		int capacity[MAX_V][MAX_V] = { 0, };
		int E, here, there, C, answer;

		scanf("%d %d", &V, &E);
		for (int i = 0; i < E; ++i) 
		{
			scanf("%d %d %d", &here, &there, &C);
			capacity[here][there] = C;
		}

		answer = networkFlow(0, V - 1, capacity);

		printf("#%d %d\n", test_case, answer);
	}
	return 0;
}


```





## 19. Bipartite Match

 그래프의 최대 이분 매칭은 두 간선이 같은 정점을 공유하지 않는 간선의 최대 집합을 말한다. A그룹과 B그룹이 있다. 각각의 그룹에는 1부터 시작하는 n명의 멤버들이 있으며, 서로 다른 그룹의 멤버들을 연결하는 선이 존재한다. 이 때, 서로 다른 그룹의 멤버끼리 2명씩 짝을 지을 때, 가능한 최대 짝의 수를 출력하시오.

img

input

```
2 // test case 수 
3 // A그룹 멤버 수 
2 // B그룹 멤버 수 
3 // 연결 선의 수 
1 1 // A그룹1과 B그룹1 연결 
2 2 // A그룹2와 B그룹2 연결 
3 2 // A그룹3과 B그룹2 연결 
4 
5 
8 
1 1 
1 2 
1 3 
2 2 
2 3 
2 4 
3 3 
4 5
```

output

```
#1 2 // 가능한 최대 짝의 수 
#2 4
```

python

```python
MAX = 1000
matchA = [0] * MAX
matchB = [0] * MAX
adj = [[0] * MAX for i in range(MAX)]
visited = [False] * MAX


def dfs(a):
    if visited[a]:
        return False
    visited[a] = True
    for b in range(0, countB):
        if adj[a][b] != 0 and (matchB[b] == -1 or dfs(matchB[b])):
            matchA[a] = b
            matchB[b] = a
            return True
    return False


def bipartiteMatch():
    size = 0
    for start in range(0, countA):
        for i in range(0, countA):
            visited[i] = False
        if dfs(start):
            size += 1
    return size


def initialize():
    for i in range(0, countA):
        matchA[i] = -1
        for j in range(0, countB):
            adj[i][j] = 0
    for i in range(0, countB):
        matchB[i] = -1


def main():
    global visited, countA, countB
    T = int(input())
    for test_case in range(1, T + 1):
        countA = int(input())
        countB = int(input())
        initialize()
        adjCount = int(input())
        for i in range(0, adjCount):
            a, b = map(int, input().split())
            adj[a - 1][b - 1] = 1
        print("#%d %d" % (test_case, bipartiteMatch()))


if __name__ == "__main__":
    main()
```

c

```c
#include <stdio.h>

#define MAX 1000

int countA, countB;
int matchA[MAX];
int matchB[MAX];
int adj[MAX][MAX];
int visited[MAX];

int dfs(int a)
{
	int b;

	if (visited[a])
	{
		return 0;
	}

	visited[a] = 1;

	for (b = 0; b < countB; ++b)
	{
		if (adj[a][b] && (matchB[b] == -1 || dfs(matchB[b])))
		{
			matchA[a] = b;
			matchB[b] = a;
			return 1;
		}
	}

	return 0;
}

int bipartiteMatch(void)
{
	int size = 0;
	int start;
	int i;
	for (start = 0; start < countA; ++start)
	{
		for (i = 0; i < countA; i++)
		{
			visited[i] = 0;
		}
		if (dfs(start))
		{
			size++;
		}
	}
	return size;
}

void initialize(void) 
{
	int i, j;
	for (i = 0; i < countA; i++)
	{
		matchA[i] = -1;
		for (j = 0; j < countB; j++)
		{
			adj[i][j] = 0;
		}
	}

	for (i = 0; i < countB; i++)
	{
		matchB[i] = -1;
	}
}

int main(int argc, char* argv[]) 
{

	int T, adjCount;
	
	scanf("%d", &T);

	for (int test_case = 1; test_case <= T; test_case++)
	{
		scanf("%d", &countA);
		scanf("%d", &countB);

		initialize();

		scanf("%d", &adjCount);

		for (int i = 0; i < adjCount; i++) 
		{
			int a, b;
			scanf("%d", &a);
			scanf("%d", &b);
			adj[a - 1][b - 1] = 1;
		}
 		printf("#%d %d\n", test_case, bipartiteMatch());
	}
	return 0;
}
```



## 간단 개념들

- stack

 Stack은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조(LIFO - Last In First Out)로 데이터를 저장하는 형식을 말한다.  

- queue

 Queue는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말한다.  

- priority queue

 Priority Queue는 높은 우선순위를 가진 원소는 낮은 우선순위를 가진 원소보다 먼저 처리되는 자료구조이다. 

- hash

 Hash table은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추가에 사용되는 자료 구조이다. Hash table은 Hash 함수를 사용하여 색인(index, Key)을 버킷(bucket)이나 슬롯(slot)의 배열로 계산한다.  

- tree

 트리 구조란 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조이다. 간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리라고 부른다. 

- graph

 컴퓨터 시스템에 그래프는 연결되어 있는 객체간의 관계를 표현할 수 있는 자료구조다. 

- linked list

 Linked List는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다. 

- deque

 Deque 는 Queue 의 일반화 된 버전으로 Queue 의 양 끝에서 데이터의 삽입 /삭제가 가능하게끔 만든 자료구조이다. 

- map

 Map 은 키를 값에 매핑할 수 있는 자료구조로 키에 대한 중복을 허용하지 않는다. 

- set

 Set 은 집합을 정의하며 요소의 중복을 허용하지 않는 자료구조이다. 